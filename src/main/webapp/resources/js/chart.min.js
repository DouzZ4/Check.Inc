/*
 Lightweight local Chart-ish implementation (minimal) to render simple line charts.
 This is NOT Chart.js. It implements a small subset of the API used by the app:
   new Chart(ctx, config)
 where `ctx` is a 2D canvas context and `config` contains:
   - type: 'line'
   - data: { labels: [...], datasets: [{ data: [...], borderColor, backgroundColor, pointRadius, pointBackgroundColor, tension, fill }] }
   - options: { responsive: true }

 The goal: render a readable trend line for glucose without external dependencies.
*/
(function(window){
    'use strict';

    function drawLineChart(ctx, config){
        var canvas = (ctx.canvas ? ctx.canvas : ctx);
        var w = canvas.width;
        var h = canvas.height;
        // Clear
        ctx.clearRect(0,0,w,h);

        var labels = (config.data && config.data.labels) || [];
        var ds = (config.data && config.data.datasets && config.data.datasets[0]) || {data:[]};
        var values = ds.data || [];
        if (values.length === 0) return {destroy:function(){}, update:function(){}};

        // Padding and plotting area
        var pad = 36;
        var plotW = w - pad*2;
        var plotH = h - pad*2;

        // compute min/max
        var min = Math.min.apply(null, values);
        var max = Math.max.apply(null, values);
        if (min === max) { min = min - 10; max = max + 10; }

        // draw axes
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(pad, pad);
        ctx.lineTo(pad, pad+plotH);
        ctx.lineTo(pad+plotW, pad+plotH);
        ctx.stroke();

        // y ticks
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        var ticks = 4;
        for(var t=0;t<=ticks;t++){
            var yv = min + (max-min)*(t/ticks);
            var y = pad + plotH - ( (yv - min)/(max-min) )*plotH;
            ctx.fillText(Math.round(yv), 6, y+4);
            // horizontal grid
            ctx.strokeStyle = '#f5f5f5';
            ctx.beginPath();
            ctx.moveTo(pad, y);
            ctx.lineTo(pad+plotW, y);
            ctx.stroke();
        }

        // compute x positions
        var n = values.length;
        var xs = [];
        for(var i=0;i<n;i++) xs.push(pad + (i/(n-1 || 1))*plotW);

        // path
        ctx.beginPath();
        for(var i=0;i<n;i++){
            var v = values[i];
            var x = xs[i];
            var y = pad + plotH - ((v - min)/(max-min))*plotH;
            if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.strokeStyle = ds.borderColor || '#3058a6';
        ctx.lineWidth = ds.borderWidth || 2;
        ctx.stroke();

        // fill area
        if (ds.fill) {
            ctx.lineTo(pad+plotW, pad+plotH);
            ctx.lineTo(pad, pad+plotH);
            ctx.closePath();
            ctx.fillStyle = ds.backgroundColor || 'rgba(48,88,166,0.12)';
            ctx.globalAlpha = 0.6;
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }

        // draw points
        var pr = ds.pointRadius !== undefined ? ds.pointRadius : 3;
        for(var i=0;i<n;i++){
            var v = values[i];
            var x = xs[i];
            var y = pad + plotH - ((v - min)/(max-min))*plotH;
            ctx.beginPath();
            ctx.fillStyle = ds.pointBackgroundColor || '#f45501';
            ctx.arc(x, y, pr, 0, Math.PI*2);
            ctx.fill();
        }

        // labels (x)
        ctx.fillStyle = '#444';
        ctx.font = '11px Arial';
        var step = Math.ceil(labels.length/6);
        for(var i=0;i<labels.length;i+=step){
            var lbl = labels[i];
            var x = pad + ( (i/(labels.length-1 || 1))*plotW );
            ctx.fillText(lbl, x-10, pad+plotH+16);
        }

        return {
            destroy: function(){ ctx.clearRect(0,0,w,h); },
            update: function(newCfg){ if (newCfg) config = newCfg; drawLineChart(ctx, config); }
        };
    }

    function Chart(ctxOrCtx2d, config){
        // Accept either canvas element or 2d context
        var ctx = ctxOrCtx2d && ctxOrCtx2d.getContext ? ctxOrCtx2d.getContext('2d') : ctxOrCtx2d;
        if (!ctx) {
            console.warn('Chart: canvas 2D context not provided');
            return {destroy:function(){}, update:function(){}};
        }
        if (!config || config.type !== 'line') return {destroy:function(){}, update:function(){}};

        // Ensure canvas has sensible pixel size for clarity
        var canvas = ctx.canvas;
        function ensureSize(){
            if (!canvas.style.height) canvas.style.height = canvas.height + 'px';
            if (!canvas.style.width) canvas.style.width = canvas.width + 'px';
        }
        ensureSize();

        return drawLineChart(ctx, config);
    }

    // Expose
    window.Chart = Chart;

})(window);
